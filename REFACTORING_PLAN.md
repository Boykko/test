# План рефакторинга модуля Battle (Features/Battle)

В данном документе описан пошаговый план рефакторинга системы битвы для улучшения поддерживаемости, тестируемости и читаемости кода.

## 1. Проблема текущей реализации
- **Толстые хуки**: `useBattleSystem` выполняет слишком много задач: управление очередью, обработка визуальных эффектов, синхронизация состояния.
- **Смешивание логики**: Логика обработки сетевых событий перемешана с UI-логикой и анимациями.
- **Сложность тестирования**: Из-за тесной связанности с сокетами и визуальными эффектами, бизнес-логику сложно тестировать в изоляции.
- **Риск Race Conditions**: Обработка очереди событий через `useEffect` может приводить к рассинхрону при быстрых обновлениях.

---

## 2. Пошаговый план

### Этап 1: Инкапсуляция логики очереди (Queue Processor)
**Что сделать**: Вынести логику из `useEffect` в `useBattleSystem` в отдельный менеджер или специализированный хук/класс.
- **Куда**: `src/features/battle/model/useBattleProcessor.ts`
- **Почему**: Чтобы `useBattleSystem` стал декларативным фасадом, а не императивным циклом.
- **Плюсы**: Четкое разделение ответственности. Проще отлаживать порядок выполнения команд.

### Этап 2: Типизация и контракты событий
**Что сделать**: Заменить `any` в `BATTLE_EVENT` и других нагрузках очереди на строгие интерфейсы.
- **Куда**: `src/features/battle/model/events.ts`
- **На что повлияет**: Потребует обновления `useBattleEvents` и серверных моков.
- **Плюсы**: Ошибки будут видны на этапе компиляции, а не во время игры.

### Этап 3: Декомпозиция `useBattleActions`
**Что сделать**: Разделить действия на категории: `MatchmakingActions`, `GameActions`, `DevActions`.
- **Куда**: `src/features/battle/model/actions/`
- **Почему**: Файл на 140 строк с разнородными действиями сложно поддерживать.
- **Плюсы**: Улучшение навигации по коду.

### Этап 4: Оптимизация визуальной системы
**Что сделать**: В `useBattleVisuals.ts` сейчас много пробросов (proxy) функций. Использовать контекст или более прямой доступ к триггерам анимаций.
- **На что повлияет**: Уменьшит количество перерендеров при вызове анимаций.
- **Плюсы**: Повышение производительности на слабых устройствах.

### Этап 5: Вынос стейта в Zustand (Опционально)
**Что сделать**: Рассмотреть переход с `useReducer` на `zustand` для `battleStore`.
- **Почему**: `useReducer` в React может быть медленным при глубоких деревьях компонентов. Zustand позволит компонентам подписываться только на нужные части состояния боя (например, только на здоровье героя).
- **Плюсы**: Значительное упрощение проброса пропсов через слои UI.

---

## 3. Таблица изменений

| Файл | Текущая роль | Новая роль |
| :--- | :--- | :--- |
| `useBattleSystem.ts` | "Оркестратор всего" | Тонкий фасад над процессором и стейтом |
| `useBattleQueue.ts` | Слушатель сокетов | Чистый менеджер входящего потока |
| `battleReducer.ts` | Логика обновления | (Без изменений или переход на Zustand) |
| `useBattleEvents.ts` | Визуальный маппинг | Обработчик визуальных побочных эффектов |

---

## 4. Ожидаемые преимущества
1.  **Скорость разработки**: Новые механики (например, новые типы событий или анимаций) добавляются в изолированные файлы.
2.  **Стабильность**: Снижение вероятности "зависания" очереди событий.
3.  **Читаемость**: Каждый файл выполняет ровно одну задачу (Solid SRP).
4.  **Тестируемость**: Возможность написать Unit-тесты на логику обработки событий без мока всего React-окружения.

---

## 5. Риски
- Временная регрессия в анимациях при изменении логики `sleep` и задержек.
- Необходимость синхронизации изменений с серверной частью (Socket API).
